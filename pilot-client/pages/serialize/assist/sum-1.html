<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<link rel='stylesheet' href='../../../plugins/googleapis/fonts.css'>
<link rel="stylesheet" href="../../../dist/css/markdown.css">
</head>
<body class='typora-export os-windows'><div class='typora-export-content'>
<div id='write'  class=''><ul><li><p><strong><span>序列化与反序列化</span></strong></p><p><span>序列化和反序列化是指用于将对象或数据结构转换为字节流的过程，以便在不同系统之间进行传输或存储，并在需要时重新构造。</span></p><ul><li><p><span>序列化是指将对象或数据结构转换为字节流的过程。在序列化过程中，对象的状态和数据被转换为一系列字节，这些字节可以按照一定的协议进行传输或存储。序列化通常用于将对象存储到磁盘或通过网络发送到其他系统。序列化后的字节流可以被保存下来，以后可以通过反序列化操作重新构建对象并恢复其状态和数据。</span></p></li><li><p><span>反序列化是指将序列化后的字节流转换回对象或数据结构的过程。在反序列化过程中，字节流被读取并解析，以还原为原始的对象或数据结构。反序列化通常用于从磁盘加载保存的对象或接收通过网络传输的序列化数据。通过反序列化，可以重新构建对象并恢复其之前序列化的状态和数据。</span></p></li></ul><p><span>序列化和反序列化在许多领域都有广泛的应用，例如分布式系统、持久化存储、缓存机制以及跨平台通信。它们允许将复杂的对象或数据结构转换为字节流进行传输或存储，从而实现不同系统之间的数据交换和共享。</span></p></li></ul><p></br></p><ul><li><p><strong><span>反序列化漏洞介绍</span></strong></p><p><span>不安全的反序列化是指在反序列化过程中存在潜在安全风险的情况，如果序列化的内容可控，在传递给应用进行反序列化时，可能会导致执行恶意代码或触发其他不受控制的行为。</span></p></li></ul><p></br></p><ul><li><p><strong><span>漏洞成因</span></strong></p><ol><li><p><span>不受限制的反序列化：如果反序列化操作没有适当的验证和限制，允许任意的序列化数据被反序列化，攻击者可以构造恶意的序列化数据来执行恶意代码。</span></p></li><li><p><span>未经过滤的输入：如果反序列化操作接受未经过滤的输入数据，攻击者可以通过构造特定的恶意数据来执行命令或导致不受控制的行为。</span></p></li><li><p><span>自定义的反序列化逻辑：如果使用自定义的反序列化逻辑而不是使用安全的序列化库或框架，可能会导致安全问题。自定义逻辑可能缺乏必要的安全验证和过滤步骤，从而容易受到攻击。</span></p></li><li><p><span>恶意的序列化数据：如果攻击者能够在反序列化操作中提供恶意构造的序列化数据，可能会导致命令执行或其他不受控制的行为。</span></p></li></ol></li></ul><p></br></p><ul><li><p><strong><span>pickle反序列化漏洞</span></strong></p><ol><li><p><span>pickle反序列化的数据直接用于命令拼接，则会直接导致命令执行。</span></p></li></ol><ol start='2' ><li><p><span>pickle中</span><code>__reduce__</code><span>魔法函数会在一个对象被反序列化时自动执行,我们可以通过在</span><code>__reduce__</code><span>魔法函数内植入恶意代码的方式进行任意命令执行。通常会利用到Python的反弹shell。</span></p></li></ol></li></ul><p></br></p><ul><li><p><strong><span>pickle反序列化相关函数</span></strong></p><ol><li><p><code>pickle.dump()</code><span>：将obj对象序列化为字节（bytes）写入到file文件中。</span></p></li><li><p><code>pickle.load()</code><span>：从一个对象文件中读取序列化数据，将其反序列化之后返回一个对象。</span></p></li><li><p><code>pickle.dumps()</code><span>：方法将obj对象序列化并返回一个bytes对象。</span></p></li><li><p><code>pickle.loads()</code><span>：将bytes反序列化并返回一个对象。</span></p></li><li><p><span>pickle的更多使用：</span><a href='https://docs.python.org/zh-cn/3/library/pickle.html' target="_blank"><span>Python 对象序列化</span></a></p></li></ol></li></ul><p></br></p><ul><li><p><strong><span>pickle前置知识之Python基础</span></strong></p><ol><li><p><a href='http://t.csdnimg.cn/vwpn7' target="_blank"><span>CSDN-Python基础语法体系（详细）</span></a></p></li><li><p><a href='https://www.runoob.com/python/python-basic-syntax.html' target="_blank"><span>菜鸟教程-Python 基础语法</span></a></p></li></ol></li></ul><p></br></p><ul><li><p><strong><span>pickle前置知识之Python魔术方法</span></strong></p><p><span>Python魔术方法（Magic Methods）是一系列特殊命名的方法，其名称以双下划头和尾（例如</span><code>__init__</code><span>和</span><code>__new__</code><span>）的形式出现，这些方法在类的特定事件被触发时自动执行，无需显式调用。这些方法允许程序员自定义类的行为，以创建更具表现力和功能的类实例。</span></p><ul><li><p><span>常用的魔术方法：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="" style="break-inside: unset;"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.51562px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">__init__(self)：实例化对象之后立即触发。</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">__reduce__(self)：在反序列化过程开始时被调用。 </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">__new__(cls)：它在__init__之前被调用，并必须返回一个对象实例。</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">__str__(self)：定义对象转换为字符串时的行为，当使用str()函数或print()函数时自动调用。</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">__call__(self)：将对象当作函数调用时触发。</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">__getattr__(self, name)：获取不存在的对象属性时被触发</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">__setattr__(self, name, value)：设置对象成员值的时候触发</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">__del__(self)：当该类对象被销毁时，自动触发。</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">__len__(self)：被传入len()时调用</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">__repr__(self)：在实例被传入repr()时被调用</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 438px;"></div><div class="CodeMirror-gutters" style="display: none; height: 438px;"></div></div></div></pre></li></ul><ul><li><p><span>更多魔术方法：</span><a href='https://blog.csdn.net/spiritx/article/details/132590256' target="_blank"><span>CSDN-Python魔术方法</span></a></p></li></ul></li></ul><p></br></p><ul><li><p><strong><span>pickle反序列化进阶之错误使用产生RCE</span></strong></p><p><span>不安全的序列化数据直接进行命令拼接或执行，产生命令执行漏洞。此种类型漏洞利用难度低，只要正确拼接了命令，即可完成攻击。</span></p></li></ul><p></br></p><ul><li><p><strong><span>pickle反序列化进阶之reduce进行RCE</span></strong></p><ol><li><p><span>产生原因：Python 中的魔术方法 </span><code>__reduce__()</code><span>在反序列化过程开始时被调用，所以我们可以序列化一个</span><code>__reduce__</code><span>魔术方法中有系统命令的实例并且让服务器将它反序列化，从而达到任意命令执行的效果。</span></p></li><li><p><span>攻击案例：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="python"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="python"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.51562px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">import</span> <span class="cm-variable">pickle</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">import</span> <span class="cm-variable">os</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">class</span> <span class="cm-def">Rce</span>(<span class="cm-builtin">object</span>): </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">def</span> <span class="cm-def">__reduce__</span>(<span class="cm-variable-2">self</span>):</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">return</span> (<span class="cm-variable">os</span>.<span class="cm-property">system</span>,(<span class="cm-string">'ipconfig'</span>,))</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="" cm-zwsp="">
</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">a</span> <span class="cm-operator">=</span> <span class="cm-variable">Rce</span>()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">b</span> <span class="cm-operator">=</span> <span class="cm-variable">pickle</span>.<span class="cm-property">dumps</span>(<span class="cm-variable">a</span>)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">print</span>(<span class="cm-variable">b</span>) <span class="cm-comment"># b是反序列化数据</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">pickle</span>.<span class="cm-property">loads</span>(<span class="cm-variable">b</span>) &nbsp;<span class="cm-comment"># 执行该语句进行反序列化，自动执行 __reduce__ 方法，并且执行 os.system('ipconfig')</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 276px;"></div><div class="CodeMirror-gutters" style="display: none; height: 276px;"></div></div></div></pre></li></ol></li></ul><p></br></p><ul><li><p><strong><span>漏洞危害</span></strong></p><ol><li><p><span>远程代码执行：攻击者可以通过构造恶意序列化数据注入和执行任意代码，从而完全控制目标系统，并执行恶意操作。</span></p></li><li><p><span>远程命令执行：攻击者可以通过反序列化漏洞在目标系统上执行远程命令，从而对其他系统或网络资源造成进一步的威胁。</span></p></li><li><p><span>信息泄露：攻击者可以利用反序列化漏洞读取和获取目标系统中的敏感信息，例如数据库凭据、用户密码、加密密钥等。</span></p></li><li><p><span>拒绝服务（DoS）攻击：攻击者可以发送恶意序列化数据来触发异常或消耗过多的系统资源，导致系统崩溃或无法提供正常的服务。</span></p></li></ol></li></ul><p></br></p><ul><li><p><strong><span>修复建议</span></strong></p><ul><li><p><span>不要将不安全的反序列化数据应用在命令执行等高危操作中。</span></p></li><li><p><span>使用安全的序列化库或框架，这些库经过严格测试和审查，并提供了适当的安全防护机制。</span></p></li><li><p><span>对反序列化输入进行严格的验证和过滤，只接受预期的数据格式和内容。</span></p></li><li><p><span>不要从不受信任的来源接受序列化数据，尽量限制数据来源。</span></p></li><li><p><span>定期更新和修复序列化库和相关组件，以获取最新的安全修补程序。</span></p></li><li><p><span>配置系统和应用程序的安全设置，限制恶意代码执行的可能性。</span></p></li></ul></li></ul><p></br></p><ul><li><p><strong><span>参考文章</span></strong></p><ol><li><p><a href='https://www.cnblogs.com/wjrblogs/p/14057784.html' target="_blank"><span>Python 反序列化漏洞学习笔记</span></a></p></li><li><p><a href='https://blog.gm7.org/%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/01.%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/02.web%E6%BC%8F%E6%B4%9E/27.%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/' target="_blank"><span>d4m1ts知识库-不安全的反序列化</span></a></p></li><li><p><a href='https://xz.aliyun.com/t/14061' target="_blank"><span>先知-pickle反序列化漏洞基础知识与绕过简析</span></a></p></li></ol></li></ul></div></div>
</body>
</html>